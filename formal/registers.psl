vunit i_registers(registers(synthesis))
{

   -- set all declarations to run on clk
   default clock is rising_edge(clk_i);


   ----------------------------------------------
   -- INTERNAL ASSERTIONS
   ----------------------------------------------


   ----------------------------------------------
   -- ASSERTIONS ON OUTPUTS
   ----------------------------------------------

   signal f_write_to_r14 : std_logic;
   f_write_to_r14 <= '1' when wr_en_i = '1' and wr_addr_i = 14 else '0';

   -- Verify correct R14 behaviour: wr_en_i takes priority over wr_r14_en_i.
   f_r14_a : assert always {wr_r14_en_i and not f_write_to_r14 and not rst_i} |=> {r14_o = (prev(wr_r14_i) or X"0001")};
   f_r14_b : assert always {f_write_to_r14 and not rst_i} |=> {r14_o = (prev(wr_val_i) or X"0001")};

   -- Write before read
   f_wbr_src : assert always {wr_en_i = '1' and rd_en_i = '1' and wr_addr_i = src_reg_i} |=> {src_val_o = prev(wr_val_i)};
   f_wbr_dst : assert always {wr_en_i = '1' and rd_en_i = '1' and wr_addr_i = dst_reg_i} |=> {dst_val_o = prev(wr_val_i)};

   -- Output only changes when rd_en_i is high (or during write-before-read)
   f_stable_src : assert always {rd_en_i = '1'; wr_en_i = '0'[*]; wr_en_i = '0' and rd_en_i = '0'} |=> {stable(src_val_o)};
   f_stable_dst : assert always {rd_en_i = '1'; wr_en_i = '0'[*]; wr_en_i = '0' and rd_en_i = '0'} |=> {stable(dst_val_o)};

   -- Write before read
   f_wbr_stable_src : assert always {rd_en_i = '1'; wr_en_i = '1' and rd_en_i = '0' and wr_addr_i = prev(src_reg_i)} |=> {src_val_o = prev(wr_val_i)};
   f_wbr_stable_dst : assert always {rd_en_i = '1'; wr_en_i = '1' and rd_en_i = '0' and wr_addr_i = prev(dst_reg_i)} |=> {dst_val_o = prev(wr_val_i)};


   ----------------------------------------------
   -- ASSUMPTIONS ABOUT INPUTS
   ----------------------------------------------

   signal f_falling_rd_en   : std_logic;
   signal f_falling_src_reg : std_logic_vector(3 downto 0);
   signal f_falling_dst_reg : std_logic_vector(3 downto 0);

   p_falling : process (clk_i)
   begin
      if falling_edge(clk_i) then
         f_falling_rd_en   <= rd_en_i;
         f_falling_src_reg <= src_reg_i;
         f_falling_dst_reg <= dst_reg_i;
      end if;
   end process p_falling;

   -- Here we make sure that the input signals only transition on the rising
   -- clock edge, not on the falling clock edge.
   assume always {not clk_i} |-> {f_falling_rd_en = rd_en_i and f_falling_src_reg = src_reg_i and f_falling_dst_reg = dst_reg_i};


   ----------------------------------------------
   -- COVER STATEMENTS TO VERIFY REACHABILITY
   ----------------------------------------------

   -- Useful for debugging, to make sure that the rd_en_i input signal is able to toggle.
   f_toggle : cover {rd_en_i = '1'; rd_en_i = '0'; rd_en_i = '1'};


   ----------------------------------------------
   -- ADDITIONAL ASSERTS NEEDED FOR K-INDUCTION
   ----------------------------------------------


   ----------------------------------------------
   -- ADDITIONAL ASSUMES HELPFUL WHEN DEBUGGING
   ----------------------------------------------


} -- vunit i_registers(registers(synthesis))

